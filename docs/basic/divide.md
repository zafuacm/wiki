# 递归

递归是分治思想的一个应用，是一种编程技巧。

归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。

递归一般包含两个条件，结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。

## 举例

> 要理解递归，就得先理解什么是递归。

递归在数学中非常常见。例如，自然数的定义（Peano 公理）：$0$ 是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。

理解递归，我们只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的，不必跳进这个函数里面企图探究更多细节。

假如我们要计算阶乘，初始值 $f(1) = 1$，且 

$$
f(n) = nf(n-1)
$$

于是

```cpp
int f(int n) {
    if (n == 1)
        return 1;
    return n * f(n - 1);
}
```

假如我们要计算 Fibonacci 数列，初始值 $f(1) = f(2) = 1$，且

$$
f(n) = f(n-1) + f(n-2)
$$

于是

```cpp
int f(int n) {
    if (n <= 2)
        return 1;
    return f(n) + f(n - 1);
}
```

递归有很多优点，结构清晰，可读性强。

## 递归的缺点

在程序执行中，递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 **栈溢出** 的后果。

因为栈本身存在额外的开销，而循环没有。初级的递归实现可能会因为递归次数太多，容易超时。这时需要对递归进行优化，或者尝试非递归解法。

## 记忆化

递归计算阶乘还不太慢，但假若计算的是 Fibonacci 数列第 $100$ 项，可能就等不到输出了。

究其根本，时间主要消耗在重复计算上，展开几次递归就会发现重复计算了很多的数据。

是否可以记忆每一次计算的值，等后面用的时候再用呢？

```cpp
int fib[MAXN], vis[MAXN];

int f(int n) {
    if (n <= 2)
        return 1;
    if (!vis[n]) {
        fib[n] = f(n - 1) + f(n - 2);
        vis[n] = 1;
    }
    return fib[n];
}
```

我们增加了 `vis` 数组，用来标志 $f(n)$ 是否计算过，如果没有计算过才去计算它，若计算过就直接返回。

## 回溯法

回溯就不讲了，想了解的自己看吧。[Link](https://oi-wiki.org/search/backtracking/)

## 例题

- [P2089 烤鸡](https://www.luogu.com.cn/problem/P2089)
- [P1464 Function](https://www.luogu.com.cn/problem/P1464)
