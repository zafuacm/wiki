---
comments: true
---

# 时间复杂度初步

2023 年主流家用 CPU 的主频在 3GHz 左右，可以不准确的理解为每秒可以执行 $3 \times 10^9$ 次运算。

CPU 很快，但不够快。每秒数十亿次运算看起来是一个不可思议的速度，但你很容易触碰到性能的上限。

本节将引入时间复杂度的概念，以定量的描述算法的执行时间。

## TLE？

你可能刷题时遇到了返回信息是 TLE 的情况。再三检查，也检查不出来哪里出现了问题。

很多时候是你的确有一些笔误，程序陷入了错误的状态，从而无法按时退出；我们主要关注另一种，代码确实没有问题，但时间复杂度没有达到要求。具体的说，就是执行效率不够高，做了大量无用的运算，需要开动脑筋来优化。

## CCF 1034 钞票兑换 · 枚举优化

我们以一道题目为例，题目链接：[CCF 1034 钞票兑换](https://www.luogu.com.cn/problem/U160446)。

题目大意：将任意给定的整百元钞票，兑换成10元、20元、50元小钞票形式。输出兑换方案总数。

数据范围：输入需要兑换的钞票总数 $n$， $100 \leqslant n \leqslant 1.7 \times 10^{11}$。

时间限制：400 毫秒。

## 枚举

即从所有的可能的解中一一测试，判断题目的条件是否成立。常常使用搜索来实现枚举。

枚举的关键是枚举空间和枚举顺序。显然问题的可能的解空间不能太大，否则无法在规定的时间内完成，因此要尽量减小枚举的范围。

枚举的顺序也很重要，比如求最后一个满足条件的数，自然是从后往前枚举。

### 思路 0

这道题显然是可以通过枚举解决。简单起见，记兑换得到 $10$ 元 $a$ 张，$20$ 元 $b$ 张，$50$ 元 $c$ 张，并记 $n=100k$。

只需测试 $10a+20b+50c = 100k$，暴力是显然的。

```c
#include <stdio.h>
typedef long long i64;

int main() {
  i64 n, sum = 0;
  scanf("%lld", &n);
  for (i64 c = 0; c <= n / 50; c++) {
    for (i64 b = 0; b <= n / 20; b++) {
      for (i64 a = 0; a <= n / 10; a++) {
        if (a * 10 + b * 20 + c * 50 == n)
          sum++;
      }
    }
  }
  printf("%lld", sum);
}
```

三层循环一共需要枚举 $\frac{n}{50} \cdot \frac{n}{20} \cdot \frac{n}{20} = \frac{n^3}{10^4}$ 种情况。

由于枚举中进行检验的代码足够简单，我们简单的估算为每秒可以进行 $10^9$ 次枚举。

针对题目的四个样例，我们可以进行大概的估算：

| 数据规模               | 枚举次数           | 估算时间       | 实际测量  |
| :--------------------- | :----------------- | :------------- | :-------- |
| $n=100$                | $10^2$             | 100 纳秒       | 0 毫秒    |
| $n=4 \times 10 ^4$     | $6.4 \times 10^9$  | 6400 毫秒      | 3147 毫秒 |
| $n=2 \times 10^6$      | $8 \times 10^{14}$ | 222.2 小时     | -         |
| $n=2 \times 10^{10}$   | $8 \times 10^{26}$ | 25367833587 年 | -         |
| $n=1.7 \times 10^{11}$ | 留做习题           | -              | -         |

这份代码预期需要运行 253 亿年才能得到答案，可见我们的算法效率有多糟糕了，怎么可能不超时呢？我们需要优化。

### 优化 1

注意到我们在枚举三个数字，判断其和是否是 $n$。我们能否定下两个数字，反代出第三个数字？这样可以避免一层枚举。

注意到 $a = 10k - 5c - 2b$，即当 $b,c$ 确定时可以计算出 $a$，判断是否 $a \geqslant 0$ 即可。如此可以消掉一层循环。

```cpp
#include <stdio.h>
typedef long long i64;

int main() {
  i64 n, sum = 0;
  scanf("%lld", &n);
  for (i64 c = 0; c <= n / 50; c++) {
    for (i64 b = 0; b <= n / 20; b++) {
      i64 a = n / 10 - 5 * c - 2 * b;
      if (a >= 0)
        sum++;
    }
  }
  printf("%lld", sum);
}
```

两层循环一共需要 $\frac{n}{50} \cdot \frac{n}{20} = \frac{n^2}{10^3}$ 次枚举。

我们可以继续估算：

| 样例规模               | 枚举次数           | 估算时间  | 实际测量  |
| :--------------------- | :----------------- | :-------- | :-------- |
| $n=100$                | $10$               | 10 纳秒   | 0 毫秒    |
| $n=4 \times 10 ^4$     | $1.6 \times 10^6$  | 1.6 毫秒  | 1 毫秒    |
| $n=2 \times 10^6$      | $4 \times 10^9$    | 4000 毫秒 | 2227 毫秒 |
| $n=2 \times 10^{10}$   | $4 \times 10^{17}$ | 4629 天   | -         |
| $n=1.7 \times 10^{11}$ | 留做习题           | -         | -         |

不错，我们成功的从 253 亿年优化到了 4629 天，起码能活着看到结果了。能不能再给力一点呢？

### 优化 2

对 $a \geqslant 0$ 求解，得到 $b \leqslant 5k-2.5c$。因此 $b$ 是 $[0,5k-2.5c]$ 之间的整数，即我们需要求和

$$
\sum_{c = 0}^{2k} \lfloor 5k - 2.5c + 1 \rfloor
$$

又消掉一层。

```cpp
#include <stdio.h>
typedef long long i64;

int main() {
  i64 n, sum = 0;
  scanf("%lld", &n);
  for (i64 c = 0; c <= n / 50; c++) {
    sum += (n - 50 * c) / 20 + 1;
  }
  printf("%lld", sum);
}
```

现在只需 $\frac{n}{50}$ 次枚举了。继续估算：

| 样例规模               | 枚举次数           | 估算时间  | 实际测量  |
| :--------------------- | :----------------- | :-------- | :-------- |
| $n=100$                | $2$                | 2 纳秒    | 0 毫秒    |
| $n=4 \times 10 ^4$     | $800$              | 0.8 微秒  | 0 毫秒    |
| $n=2 \times 10^6$      | $4 \times 10^4$    | 40 微秒   | 0 毫秒    |
| $n=2 \times 10^{10}$   | $4 \times 10^8$    | 400 毫秒  | 290 毫秒  |
| $n=1.7 \times 10^{11}$ | $3.4 \times 10 ^9$ | 3400 毫秒 | 2134 毫秒 |

非常精彩的优化，从 4629 天优化到了 3.4 秒。但是很遗憾我们离最终目标 400 毫秒还有一定的距离。可以再给力一点吗？

### 优化 3

优化 2 中我们得到了一个求和式，其实可以使用一定的数学技巧对求和式直接化简。提出首项

$$
\sum_{i=0}^{2k}\lfloor 5k-2.5i   + 1\rfloor
= 5k + 2k + \sum_{i=1}^{2k}\lfloor 5k-2.5i \rfloor
$$

分奇偶展开有

$$
\begin{aligned}
\sum_{i=1}^{2k}\lfloor 5k-2.5i \rfloor
&= \sum_{i=1}^{k}\lfloor 5k-2.5(2i-1) \rfloor + \sum_{i=1}^{k}\lfloor 5k-2.5(2i) \rfloor \\
&= \sum_{i=1}^{k}(10k-10i+2) \\
&= 5k^2 -3k + 1
\end{aligned}
$$

于是可以写出代码

```cpp
#include <stdio.h>
typedef long long i64;

int main() {
  i64 n, sum = 0;
  scanf("%lld", &n);
  sum = (5 * k + 4) * k + 1;
  printf("%lld", sum);
}
```

此时枚举已经完全被我们优化掉了，无论怎样的数据范围都可以直接的计算出答案。

!!! info "提示"
    直接抄是过不了题的，还有需要修正，观察一下数据范围。有时候拿不了全分，也要争取部分分。

## 复杂度

思考的深度不同，对应代码的效率差距天差地别。学会分析自己思路的复杂度，是一个必须掌握的技能。

不但可以对时间分析复杂度，也可以对内存空间进行复杂度分析。

### 大 O 记法

一般对算法的计算资源进行精确的分析太繁琐，也无法捕捉到关键信息，因此算法的复杂度往往使用渐进形式表达，即大 $O$ 记法。

对于函数 $f, g$，假如任取 $n$，存在大整数 $N$ 和系数 $C$ 使得当 $n > N$ 时恒有 $0 < f(n) < C g(n)$，就记作 $f(n) \in O(g(n))$。

比如 $n \in O(n)$，$2.5n + 3 \in O(n)$，$\frac{n^3}{1000} \in O(n^3)$。

这种记法可以让我们更准确的把握程序所需的计算资源和数据规模 $n$ 之间的关系。

前文的四份代码的复杂度分别为 $O(n^3)$、$O(n^2)$、$O(n)$、$O(1)$。

## 习题

这个函数的复杂度是多少？

```c
int f(int n) {
  if (n <= 2)
    return 1;
  else
    return f(n - 1) + f(n - 2);
}
```

## 参考阅读

- [复杂度 - OIWiki](https://oi-wiki.org/basic/complexity)
